---
title: "Занятие 01: структуры данных в R"
author: "Алла Тамбовцева"
output: html_document
---

## Векторы

### Вектор как структура данных, типы данных и приведение типов

Вектор — основная структура данных в R. Он представляет собой упорядоченный набор элементов одного типа. Если проводить аналогию со структурами данных в Python, вектор можно сравнивать с массивом (чаще одномерным, хотя создать сложный «вектор векторов» тоже можно). 

Зачем изучать работу с векторами, если обычно в реальной жизни мы работаем с таблицами? Когда мы загружаем данные в табличном виде из файла в R, каждый столбец в таблице воспринимается R как отдельный вектор определенного типа (числового, текстового или логического). Да и при извлечении некоторых элементов из результатов статистических тестов так или иначе придется иметь дело с векторами. 

Создается вектор с помощью функции `c()`, от *combine*. Эта функция объединяет элементы в вектор. Создадим вектор `v1`, состоящий из целых чисел:

```{r}
v1 <- c(3, 6, 8, 9)
v1
```

**Примечание:** оператор `<-` используется для присваивания значений переменным (как `=` в Python и других языках). Оператор `=` тоже можно использовать, технически это не вызовет проблем, но все-таки это считается в R неправильным:

```{r}
v1 = c(3, 6, 8, 9)
v1
```

Так как вектор умеет хранить элементы только одного типа, при наличии разных типов внутри вектора один самый сильный тип неизбежно вытеснит другие. Например, числовой тип (*numeric*, вещественные числа, то есть целые и дробные) сильнее целочисленного типа (*integer*):

```{r}
v2 <- c(3, 6.6, 8, 9)
v2
```

Из-за числа 6.6 все значения стали дробными (обратите внимание, в качестве десятичного разделителя в R используется точка). А текстовый тип (*character*), в свою очередь, сильнее числового и целочисленного:

```{r}
v3 <- c("2,5", "3", 8, 9)
v3
```

Проверим типы созданных векторов. Функция `class()` возвращает класс объекта в R, а функция `typeof()` — более точную спецификацию типа:

```{r}
class(v1); typeof(v1)
class(v2); typeof(v2)
class(v3); typeof(v3)
```

**Примечание:** если перечислять какие-то команды через `;` в одну строку, они будут исполняться сразу друг за другом. 

Теперь давайте выполним приведение типов — сконвертируем один тип в другой. Это понадобится нам позже для обработки реальных данных — если столбец имеет неверный тип, это может смущать (при чтении файла что-то пошло не так, и целочисленные коды ответов в опросе стали дробными) или мешать при построении графиков и применении подходящих методов анализа.

Сделаем вектор `v1` целочисленным (там и так целые числа, но R по умолчанию создал вектор более общего типа *numeric*) и сохраним результат конвертации в вектор `v4`. Воспользуемся функцией `as.integer()`:

```{r}
v4 <- as.integer(v1)
v4
class(v4); typeof(v4)
```

Все функции для приведения типов имеют название, состоящее из префикса `as` и названия типа. Проверим это и сделаем вектор `v1` текстовым:

```{r}
v5 <- as.character(v1)
v5
```

Теперь посмотрим, как работать с отдельными элементами вектора.

### Извлечение элементов вектора

Так как вектор — упорядоченная структура, элементы вектора извлекаются по индексу (порядковому номеру). В отличие от Python, в R нумерация элементов начинается с 1, а не с 0, что более привычно. 

Создадим более длинный вектор `long` и извлечем из него первый элемент:

```{r}
long <- c(1, 9, 8, 4, 1, 9, 8, 5)
long[1]
```

Если вызовем элемент с номером 0, получим «пустой» ответ:

```{r}
long[0]
```


Последний элемент можно вызвать, определив длину вектора — число элементов в нем:

```{r}
length(long)
long[length(long)]
```

Если нас интересует не один элемент, а сразу несколько, идущих подряд, выбрать их можно с помощью срезов:

```{r}
long[2:4]
```

**Примечание:** в отличие от Python, в R правый конец среза тоже включается в итоговый вектор выбранных элементов (здесь со второго элемента до четвертого включительно). 

Также, в отличие от Python, в R нельзя исключить какой-либо из концов среза, это приведет к ошибке синтаксиса (`unexpected ']'`):

```{r, eval=FALSE}
long[2:]
```

Если нужны элементы со второго до последнего, придется снова обращаться к длине вектора:

```{r}
long[2:length(long)]
```

А что будет, если мы запросим элементы со второго по девятый (всего элементов восемь)?

```{r}
long[2:9]
```

R не выдаст ошибку, но на место несуществующего девятого элемента допишет `NA` — пустое значение (от *not applicable*). Как можно догадаться, если мы запросим элементы со второго по десятый, в конце вектора уже будет два `NA`:

```{r}
long[2:10]
```

Если нам нужны элементы, стоящие не подряд, их индексы нужно объединять в вектор:

```{r}
# 2nd, 5th, 8th
long[c(2, 5, 8)]
```

Объединять обычные вектора и срезы при этом тоже можно:

```{r}
long[c(2, 5:8)]
```

```{r}
long[c(2, 5, 1:6)]
```

А можно ли в R, как в Python, использовать отрицательные индексы? Можно, но смысл такой операции будет иной, R не умеет считать элементы с конца. Попробуем!

```{r}
long[-1]
```

Что сделал R? Он выбрал все элементы, кроме первого! Так и работают отрицательные индексы, минус перед индексом означает, что нужно выбрать все элементы, кроме указанного. Проверим на втором элементе:

```{r}
long[-2]
```

А теперь проверим на срезе:

```{r, eval = FALSE}
long[-2:length(long)]
```

Не работает — сочетать отрицательные индексы можно только с нулем:

```{r}
long[-2:0]
```

Получили все элементы, кроме первых двух. Два отрицательных индекса в срезе — тоже нормальная ситуация:

```{r}
long[-2:-4]
```

Так, здесь мы выбрали все элементы, кроме второго, третьего и четвертого.

### Объединение векторов

Не исключено, что по аналогии с Python захочется склеивать векторы с помощью оператора `+`. Однако в R этот оператор используется для поэлементного сложения векторов:

```{r}
c(3, 7, 8) + c(1, 2, 0)
```

Если длины векторов разные, R выведет сообщение с предупреждением и сделает довольно неожиданную вещь — когда элементы более короткого вектора «закончатся», R начнет проходить этот вектор с самого начала. Рассмотрим пример:

```{r}
c(3, 7, 8) + c(1, 2)
```

Почему в конце мы получили число 9? В первом векторе последний элемент складывать не с чем, во втором векторе всего два элемента. Поэтому R возвращается к началу второго вектора и складывает 8 с его первым элементом 1. Убедимся в этом на другом примере:

```{r}
c(3, 7, 8, 10) + c(1, 2)
```

А все-таки, как объединить несколько векторов в один? Воспользоваться уже знакомой функцией `c()`:

```{r}
c(c(3, 7, 8), c(1, 2))
```

### Последовательности

Если мы хотим получить векторы из целых чисел, идущих друг за другом, можно воспользоваться оператором `:` (аналог функции `range()` в Python с той разницей, что здесь правый конец среза тоже включается):

```{r}
1:10
```

```{r}
25:40
```

А если мы хотим получить наборы чисел с шагом, отличным от 1, понадобится функция `seq()` (от *sequence*). Первым аргументом этой функции будет начальное значение, вторым — конечное, а третьим — шаг:

```{r}
seq(1, 20, 2)
```

```{r}
seq(10, 15, 0.5)
```

Если шаг нам не известен (или нам не хочется его вычислять в уме), но мы знаем, сколько точек на одинаковом расстоянии друг от друга мы хотим получить в итоге, это число точек можно указать в аргументе `length.out`. Тогда R сам вычислит необходимый шаг и вернет соответствующий вектор:

```{r}
seq(1, 20, length.out = 10)
```

В данном случае, чтобы получить 10 равноудаленных друг от друга значений на отрезке от 1 до 20, R сам вычислил шаг 2.1111... и использовал его для построения последовательности. Если бы мы считали такой шаг самостоятельно, мы бы определили, что между 10 точками должно быть 9 промежутков, и поделили длину отрезка от 1 до 20, равную 19, на 9.

Для получения векторов из одинаковых значений нам пригодится функция `rep()` (от *repeat*):

```{r}
rep("A", 3)
```

```{r}
rep(NA, 10)
```

При этом повторять можно не только отдельные значения, но и векторы. Например, если для какой-нибудь столбиковой диаграммы нам понадобится набор двух чередующихся цветов, такой набор можно получить с помощью `rep()`:

```{r}
rep(c("red", "blue"), 4)
```

А если цвета не чередуются, а просто повторяются фиксированное число раз друг за другом, потребуется аргумент `each`:

```{r}
rep(c("red", "blue"), each = 4)
```

### Встроенные векторы

Также в R есть уже готовые векторы и последовательности, которые могут быть полезны. Например, вектор со строчными буквами английского алфавита:

```{r}
letters
```

Или с заглавными буквами английского алфавита:

```{r}
LETTERS
```

Вектор с названиями месяцев на английском языке:

```{r}
month.name
```

Вектор с сокращенными названиями месяцев на английском языке:

```{r}
month.abb
```

Также можно получить вектор с названиями цветов, которые используются в R (правда, `colors()` — это уже не готовый вектор, это функция, которая такой вектор возвращает):

```{r, echo=FALSE}
# first 20 to be short
colors()[1:20]
```

Какие цвета соответствуют этим названиям, можно посмотреть [здесь](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf).

### Формат дата-время и его сочетание с последовательностями

Раз уж заговорили о последовательностях, имеет смысл поговорить о создании полезных для реальной обработки данных последовательных, связанных со специальным форматом *дата-время*. Технически, даты и метки времени можно хранить в виде обычного текста, но если мы захотим данные с такими метками сортировать или визуализировать, неизбежно возникнут проблемы — строки будут сортироваться по алфавиту, а не хронологически. 

Для создания набора дат с нуля нам понадобится функция `ISOdate()`. Она забирает формат даты и времени, используемый в системе, на компьютере, и возвращает последовательность меток вида *дата-время*. Создадим вектор для дат, представляющих собой первые числа каждого месяца этого года:

```{r}
# year 2023
# months from 1 to 12
# day 1
# time 12:00:00 GMT by default

dates <- ISOdate(2023, 1:12, 1)
dates
```

Проверим тип вектора:

```{r}
class(dates)
```

`POSIXct` и `POSIXt` — специальные форматы для даты и времени. Метки с датой и временем, которые мы создали, с одной стороны, хранят дату в виде POSIX-времени (число секунд с 1 января 1970 года, универсальный формат хранения временных данных, используется на сайтах и в социальных сетях), а с другой стороны, позволяют увидеть ее в более привычном текстовом виде.

Аналогичным образом создадим вектор со вторыми числами каждого месяца:

```{r}
ISOdate(2023, 1:12, 2)
```

А вот с последними числами будет проблема, очевидно, что не в каждом месяце 31 день:

```{r}
ISOdate(2023, 1:12, 31)
```
R на месте месяцев с другим числом дней добавил пропуски `NA`. Для корректного набора придется вместо 31 честно сформировать вектор с последними числами месяца:

```{r}
ISOdate(2023, 1:12, c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31))
```
При этом, если мы хотим извлечь из метки с датой и временем, какую-то конкретную информацию в виде обычного текста, мы тоже сможем это сделать. Понадобится функция `format()`, она извлечет нужный элемент и подставит его в составленный нами текстовый шаблон.

Для начала извлечем дату в сокращенном виде.

```{r}
# before
dates
```

```{r}
# after
format(dates, "%D")
```

Символ `%` сообщает R, что на это место нужно подставить некоторое значение (то, что мы указали в кавычках, и есть текстовый шаблон), а буква `D` соответствует дате. Текстовый шаблон мог быть и другим:

```{r}
format(dates, "Date is %D")
```

Помимо `D` есть много других полезных сокращений:

* `d`: число (номер дня);
* `B`: название месяца (на языке, используемом системой);
* `b`: сокращенное название месяца;
* `Y`: год в четырехзначном формате;
* `y`: год в двузначном формате (последние две цифры);
* `A`: название дня недели (на языке, используемом системой);
* `a`: сокращенное название дня недели;
* `H`: часы;
* `M`: минуты;
* `S`: секунды.

Посмотрим на примеры разных строк с разными элементами даты и времени (логика простая — на место `%` и буквы подставляется подходящий элемент, а сама строка может включать пробелы, скобки, двоеточия и прочие символы).

```{r}
format(dates, "%d %B %Y")
```

```{r}
format(dates, "%d %B %y")
```

```{r}
format(dates, "%d %b %y")
```

```{r}
format(dates, "%d %B %Y (%A)")
```

```{r}
format(dates, "%d %B %Y (%a)")
```
```{r}
format(dates, "%d %B %Y %H:%M:%S")
```

### Векторы и конкатенация строк

Конкатенация строк — склеивание строк, то есть приписывание одной строки в конец другой. Для склеивания строк в R используется функция `paste()`:

```{r}
paste("A", "B", "C")
```

По умолчанию в качестве разделителя используется пробел, но его можно поменять, добавив аргумент `sep` (от *separator*):

```{r}
paste("A", "B", "C", sep = "-")
```

Что замечательно, эта функция `paste()` умеет работать и с векторами тоже. То есть, используя эту функцию, к каждому элементу вектора можно доклеить какой-то текст, минуя циклы и подобные конструкции (операции в R векторизованы — применяются ко всем элементам вектора, здесь это и проявляется). Для примера доклеим к каждому числу в последовательности от 221 до 224 слово «группа»:

```{r}
paste("группа", 221:224)
```

Или так:

```{r}
paste("группа", 221:224, sep = "_")
```

Тем, кто знаком с Python, история про склеивание строк неизбежно наводит на мысль о методе `.join()`. В R такой функции нет, объединение вектора строк в одну большую строку выполняет та же функция `paste()`, но с аргументом `collapse`, в котором необходимо указать желаемый разделитель:

```{r}
parts <- c("01", "03", "2023")
paste(parts, collapse = "/")
```

## Матрицы

## Матрица как структура данных

Матрица — двумерный массив в R, то есть таблица, состоящая из элементов одного типа. С матрицами можно столкнуться, изучая сетевой анализ (матрица смежности или матрица инцидентности для описания связей между людьми или странами) или создавая небольшие таблицы для хранения данных с нуля.

Способов создания матриц несколько, мы начнем с самого простого — разобьем набор чисел от 10 до 21 на 4 строки:

```{r}
M <- matrix(10:21, nrow = 4)
M
```
По умолчанию элементы записываются по столбцам матрицы (сначала заполняется первый столбец, потом второй, и так далее). Если хочется заполнять матрицу по строкам, потребуется аргумент `byrow`:

```{r}
matrix(10:21, nrow = 4, byrow = TRUE)
```
Вернемся к матрице `M` и столбцам названия ее строкам:

```{r}
rownames(M) <- month.abb[1:4]
M
```
И заодно — названия столбцам:

```{r}
colnames(M) <- c("Nif-Nif", "Naf-Naf", "Nuf-Nuf")
M
```
Будем считать, что в матрице выше сохранено число желудей, которые собрали поросята Ниф-Ниф, Наф-Наф и Нуф-Нуф в январе, феврале, марте и апреле. Конечно, в данном случае пример игрушечный, но функции `rownames()` и `colnames()` пригодятся нам позже при работе с реальными данными, потому что названия строк и столбцов в датафреймах (таблицах) фиксируются точно так же.

### Извлечение элементов матрицы

Работа с элементами матрицы в R напоминает работу с элементами матрицы в математике — на первом месте всегда указывается номер строки, где находится элемент, на втором — номер столбца. Выберем элемент на пересечении первой строки и третьего столбца:

```{r}
M[1, 3]
```


А теперь — на пересечении третьей строки и первого столбца:

```{r}
M[3, 1]
```

Если мы хотим выбрать сразу несколько строк или столбцов, то есть «вырезать» маленькую матрицу из большой, индексы строк или столбцов нужно указывать в виде вектора (последовательности):

```{r}
M[c(2, 4), 3]
```

```{r}
M[1, 2:3]
```

### Операции со строками и столбцами матрицы

Когда мы говорим о матрицах, почти всегда речь идет о числовых матрицах. А для числовых матриц и таблиц в R есть удобные функции для подсчета сумм и средних по строкам или столбцам. Посчитаем сумму по каждому столбцу:

```{r}
colSums(M)
```

Или по каждой строке:

```{r}
rowSums(M)
```

Аналогичная история со средними значениями:

```{r}
colMeans(M)
rowMeans(M)
```

К сожалению, готовых функций для вычисления других характеристик (медиана, дисперсия, стандартное отклонение) по каждому столбцу или строке в R нет. Но, к счастью, есть более универсальная функция `apply()`, которая позволяет применять какую-то функцию к каждой строке или столбцу. 

Так, вместо `rowSums(M)` мы могли бы записать следующее:

```{r}
apply(M, 1, sum)
```

Это означает: примени функцию `sum()`, которая в R уже есть, к каждой строке в матрице `M` (1 — строки, 2 — столбцы).

Проделаем то же самое для столбцов:

```{r}
apply(M, 2, sum)
```

Вместо `sum` можно подставить любую другую функцию. Например, функцию для нахождения минимума:

```{r}
apply(M, 2, min)
```

Или дисперсии (здесь одинаковая у всех, данные такие):

```{r}
apply(M, 2, var)
```

Или стандартного отклонения:

```{r}
apply(M, 2, sd)
```

А можно вообще написать свою функцию (будем более подробно обсуждать позже), которая будет переводить значение в ячейке в проценты от столбца или строки. 

Проценты от суммы по строке:

```{r}
apply(M, 1, function(x){x / sum(x) * 100})
```

Проценты от суммы по столбцу:

```{r}
apply(M, 2, function(x){x / sum(x) * 100})
```

## Списки

## Список как структура данных

Список (*list*) в R — структура довольно специфическая, она одновременно напоминает как списки, так и словари в Python. Ключевое сходство со списками в Python заключается в том, что и те, и другие умеют хранить данные разных типов. А сходство со словарями заключается в том, что в самом простом случае список — это просто пара соответствий вида *ключ-значение*. 

Вот с примера таких соответствий мы и начнем. Создадим список `pairs`, который содержит уникальные ответы респондентов и соответствующие им обозначения:

```{r}
pairs <- list("Да" = "yes", "Нет" = "no", "Нет ответа" = NA)
pairs
```

Такого вида соответствия часто встречаются в реальной работе с данными. Например, опции в выпадающем меню, которые мы показываем пользователю в приложении, содержат понятные и аккуратно оформленные ответы вроде «Да» и «Нет», а в таблице с данными, откуда мы извлекаем данные по этим ответам, они записаны попроще и на латинице. Чтобы соединить выбор пользователя в меню с имеющимися данными, нам неизбежно потребуется сохранить доступные опции в виде пар связанных значений. 

Также списки можно использовать для хранения информации в структурированном виде (если таблица не подходит в силу специфического вида данных):

```{r}
L <- list(data = "students", 
          names = c("Elaine", "Cassandra", "Harry"), 
          marks = c(6, 8, 9))
L
```
Как можно заметить, название каждого «крупного» элемента в списке записано после `$`. Действительно, этот оператор используется для извлечения элементов по названию — в датафреймах с реальными данными будет то же самое:

```{r}
pairs$Да
```

Если название содержит пробел или нетипичные для переменных символы, его нужно вводить в специальных кавычках:

```{r}
pairs$`Нет ответа`
```

Выбирать элементы по номеру тоже можно, как в векторах:

```{r}
pairs[1]
```

Если мы указываем номер элемента в одинарных квадратных скобках, нам возвращается объект типа *список*, то есть маленький список из одного элемента. Однако если мы укажем номер элемента в двойных квадратных скобках, этот элемент будет «полностью» извлечен, то есть он будет иметь тот тип, который у него был изначально при добавлении в список.

```{r}
# not a list, just a word
pairs[[1]]
```

Сравним:

```{r}
class(pairs[1])
class(pairs[[1]])
```

Если список обладает сложной вложенной структурой, выбор элементов может быть многоступенчатым: сначала выбираем один элемент, потом внутри него другой и так далее.

Выберем первый элемент из `names` в списке `L`:

```{r}
L$names[1]
```

А теперь проделаем то же самое, только с помощью числовых индексов:

```{r}
L[[2]][1]
```

